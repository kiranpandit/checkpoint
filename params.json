{
  "name": "Checkpoint",
  "tagline": "418 project webpage",
  "body": "More on Challenges:\r\nThe challenge in this project is the division of work to enable parallelism. There are multiple ways to approach the parallelism with the problem of alpha beta pruning of minimax decision trees. Firstly, we can divide up the work between processors one of two ways: breadth wise, or depth wise. For breadthwise division, we can create different tasks for each of the first initial moves. For depthwise division we divide in a way shown in [this diagram](https://drive.google.com/open?id=0BzWuAeUClNy-N0JXVVdlS2tUY28) (from [A Comparative Study of Game Tree Searching Methods](http://thesai.org/Downloads/Volume5No5/Paper_10-A_Comparative_Study_of_Game_Tree_Searching_Methods.pdf)).\r\n![image](http://tinypic.com/r/27zhyjt/9)\r\nThe problems associated with the division of work in both cases is the maintenance of accurate cutoff values for alphabeta pruning. We can do this in two ways. Firstly, by entirely ignoring alpha beta values of other processors and maintaining local values for a given task, and sequentially choosing the best move of those that each task decides on. The second way is to pass messages between the different tasks of the updated alpha/beta cutoffs. This could be done using MPI (message passing interface).\r\nBecause there are so many ways to solve this larger problem of the calculation parallelization of the minimax game trees, the goal of this project has been the exploration of the merits of these in different cases. We hope to implement these different ideas and look at the effects it has on the speedup of a parallel version. It may also be an interesting challenge to test the parallelization of the work on a larger load (for example, using a larger board with more possible legal moves, or to a greater depth) and see if different methods are more effective for different loads.\r\n\r\nCompleted Work:\r\nWe are behind schedule due to issues with logistically setting up the assigning of tasks to threads. \r\nWhat we do have completed is a minimax version of the Othello AI. Our code calculates the best move with a depth of 3 currently, and uses the difference between the player’s own and the opposing player’s pieces as the score.\r\n \r\nGoals and Demo:\r\nThe overall goal is still to achieve an approximate 4x speedup on the 4 cores of the GHC machines. However, after consideration of the many different ways we can approach the problem, the goal is also to compare these different methods.\r\nThus, the presentation will be in two parts - a demo of playing against the AI (optimally with a nice user interface, which is still a “hope to achieve” goal), and a graph which shows the different speedups relative to sequential of the different methods of tree partitioning and task assignment we are attempting.\r\n\r\nSchedule (Revised)\r\nMinimax Othello AI (done)\r\nAlpha beta pruning (April 22 - Rohan)\r\nCreation of different board scenarios (April 22 - Kiran)\r\nMultithreading based on breadth first (April 26 - Kiran)\r\nBoth with and without alpha beta pruning\r\nMultithreading based on depth first (April 30 - Rohan)\r\nBoth with and without alpha beta pruning (April 30 - Kiran)\r\nCommunication between processes (May 4 - Kiran)\r\nCompare to lack of communication\r\nBare bones UI (May 4 - Rohan)\r\nPretty UI (May 8 - Rohan)\r\nComparison graphs for presentation (May 8 - Kiran)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}