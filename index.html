<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Checkpoint by kiranpandit</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Checkpoint</h1>
      <h2 class="project-tagline">418 project webpage</h2>
      <a href="https://github.com/kiranpandit/checkpoint" class="btn">View on GitHub</a>
      <a href="https://github.com/kiranpandit/checkpoint/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/kiranpandit/checkpoint/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>More on Challenges:
The challenge in this project is the division of work to enable parallelism. There are multiple ways to approach the parallelism with the problem of alpha beta pruning of minimax decision trees. Firstly, we can divide up the work between processors one of two ways: breadth wise, or depth wise. For breadthwise division, we can create different tasks for each of the first initial moves. For depthwise division we divide in a way shown in <a href="https://drive.google.com/open?id=0BzWuAeUClNy-N0JXVVdlS2tUY28">this diagram</a> (from <a href="http://thesai.org/Downloads/Volume5No5/Paper_10-A_Comparative_Study_of_Game_Tree_Searching_Methods.pdf">A Comparative Study of Game Tree Searching Methods</a>).
<img src="http://tinypic.com/r/27zhyjt/9" alt="image">
The problems associated with the division of work in both cases is the maintenance of accurate cutoff values for alphabeta pruning. We can do this in two ways. Firstly, by entirely ignoring alpha beta values of other processors and maintaining local values for a given task, and sequentially choosing the best move of those that each task decides on. The second way is to pass messages between the different tasks of the updated alpha/beta cutoffs. This could be done using MPI (message passing interface).
Because there are so many ways to solve this larger problem of the calculation parallelization of the minimax game trees, the goal of this project has been the exploration of the merits of these in different cases. We hope to implement these different ideas and look at the effects it has on the speedup of a parallel version. It may also be an interesting challenge to test the parallelization of the work on a larger load (for example, using a larger board with more possible legal moves, or to a greater depth) and see if different methods are more effective for different loads.</p>

<p>Completed Work:
We are behind schedule due to issues with logistically setting up the assigning of tasks to threads. 
What we do have completed is a minimax version of the Othello AI. Our code calculates the best move with a depth of 3 currently, and uses the difference between the player’s own and the opposing player’s pieces as the score.</p>

<p>Goals and Demo:
The overall goal is still to achieve an approximate 4x speedup on the 4 cores of the GHC machines. However, after consideration of the many different ways we can approach the problem, the goal is also to compare these different methods.
Thus, the presentation will be in two parts - a demo of playing against the AI (optimally with a nice user interface, which is still a “hope to achieve” goal), and a graph which shows the different speedups relative to sequential of the different methods of tree partitioning and task assignment we are attempting.</p>

<p>Schedule (Revised)
Minimax Othello AI (done)
Alpha beta pruning (April 22 - Rohan)
Creation of different board scenarios (April 22 - Kiran)
Multithreading based on breadth first (April 26 - Kiran)
Both with and without alpha beta pruning
Multithreading based on depth first (April 30 - Rohan)
Both with and without alpha beta pruning (April 30 - Kiran)
Communication between processes (May 4 - Kiran)
Compare to lack of communication
Bare bones UI (May 4 - Rohan)
Pretty UI (May 8 - Rohan)
Comparison graphs for presentation (May 8 - Kiran)</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/kiranpandit/checkpoint">Checkpoint</a> is maintained by <a href="https://github.com/kiranpandit">kiranpandit</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
